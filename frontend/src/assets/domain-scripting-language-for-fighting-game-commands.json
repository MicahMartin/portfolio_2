{ "content": "\r\nSummarizing and Explaining the Domain Scripting Language for Fighting Game Special Moves\r\nIntroduction\r\nImagine you're playing a classic fighting game like Street Fighter, where executing special moves like Ryu's Hadouken requires precise inputs. The code provided implements a domain-specific language (DSL) that interprets these input sequences and translates them into executable commands within the game.\r\n\r\nComponents of the System\r\nCommandCompiler.cpp & CommandCompiler.h\r\nPurpose: These files manage the compilation and initialization of special move commands.\r\nKey Features:\r\nCommandStrings: Defines sequences like \"F, N, F\" (forward, neutral, forward) or \"@F & !D, N, F\" (forward dash excluding down press).\r\nCompilation Process: Parses and compiles these strings into executable command functions using CommandScanner and other utility functions.\r\n\r\n```\r\n\/\/ CommandCompiler.h\r\n\r\n#ifndef _CommandCompiler_h\r\n#define _CommandCompiler_h\r\n\r\n#include <string>\r\n#include <vector>\r\n#include \"input\/CommandScanner.h\"\r\n#include \"input\/VirtualController.h\"\r\n#include <functional>\r\n\r\ntypedef std::function<bool(int, bool)> CommandFunction;\r\nstruct CommandNode {\r\n  CommandFunction function;\r\n  int bufferLength;\r\n};\r\ntypedef std::vector<CommandNode> Command;\r\n\r\nclass CommandCompiler {\r\npublic:\r\n\r\n  CommandCompiler();\r\n  ~CommandCompiler();\r\n\r\n  void init();\r\n  void compile(const char* inputString);\r\n\r\n  CommandNode compileNode();\r\n  CommandFunction binaryCommand(CommandFunction currentFunc, CommandTokenType type);\r\n\r\n  static std::vector<std::string> commandStrings;\r\n  std::vector<Command> commands;\r\n  VirtualController* controllerPointer;\r\nprivate:\r\n  CommandScanner commandScanner;\r\n  CommandToken* currentToken;\r\n};\r\n\r\n#endif \/* _CommandCompiler_h *\/\r\n```\r\n\r\nCommandScanner.cpp & CommandScanner.h\r\nPurpose: Implements the lexical analysis (scanning) of command strings.\r\nKey Features:\r\nTokenization: Splits input strings into tokens such as directions (N, F, B, etc.), button presses (LP, LK, MP, MK), and modifiers (@, *, ~, !).\r\nToken Types: Defines various token types (e.g., CTOKEN_FORWARD, CTOKEN_LP) for different inputs and modifiers.\r\nFunctionality: Handles whitespace skipping, alphanumeric checking, and token creation.\r\n\r\n```\r\n\/\/ CommandScanner.h\r\n\r\n#ifndef _CommandScanner_h\r\n#define _CommandScanner_h\r\n\r\n#include <vector>\r\ntypedef enum {\r\n  CTOKEN_NEUTRAL, CTOKEN_FORWARD, CTOKEN_BACK, CTOKEN_UP, CTOKEN_DOWN,\r\n  CTOKEN_UPFORWARD, CTOKEN_UPBACK, CTOKEN_DOWNFORWARD, CTOKEN_DOWNBACK,\r\n  CTOKEN_LP, CTOKEN_LK, CTOKEN_MP, CTOKEN_MK,\r\n  CTOKEN_NUMBER,\r\n\r\n  CTOKEN_RELEASED, CTOKEN_HELD,\r\n\r\n  CTOKEN_AND, CTOKEN_OR,\r\n\r\n  CTOKEN_ANY, \r\n  CTOKEN_NOT,\r\n  CTOKEN_DELIM,\r\n  CTOKEN_END,\r\n\r\n} CommandTokenType;\r\n\r\nstruct CommandToken {\r\n  CommandTokenType type;\r\n  const char* start;\r\n  uint8_t length;\r\n} ;\r\n\r\nclass CommandScanner {\r\npublic:\r\n  CommandScanner();\r\n  ~CommandScanner();\r\n\r\n  std::vector<CommandToken> scan(const char* inputString);\r\n\r\n  CommandTokenType getInputType();\r\n  CommandToken makeToken(CommandTokenType type);\r\n  bool isAtEnd();\r\n  char peek();\r\n  char peekNext();\r\n  char advance();\r\n  bool match(char expected);\r\n  void skipWhitespace();\r\n  bool isAlpha(char c);\r\n  bool isDigit(char c);\r\n  CommandTokenType checkKeyword(int start, int end, const char* rest, CommandTokenType type);\r\n\r\nprivate:\r\n  const char* scannerStart;\r\n  const char* scannerCurrent;\r\n};\r\n\r\n#endif \r\n```\r\n\r\nHow It Works\r\nInput Definition\r\n\r\nTokens: Each input direction (N, F, B, etc.) and button press (LP, LK, etc.) is tokenized and categorized by CommandScanner.\r\nModifiers: Symbols like @ (any), * (held), ~ (released), and ! (not) modify how inputs are interpreted.\r\nCompilation and Execution\r\n\r\nCommand Compilation: CommandCompiler initializes by compiling predefined commandStrings, translating each string into executable commands.\r\nCommandNode & CommandFunction: Each command is represented as a sequence of CommandNode structures, where each node contains a CommandFunction that evaluates whether the input matches the defined sequence.\r\nExecution: During gameplay, the compiled commands are evaluated against player input (provided by VirtualController), determining if the player successfully inputs a special move sequence.\r\nExample\r\nConsider the command string \"~D, DF, F, D, DF, F, LK | ~LK\", which translates to:\r\n\r\nInputs: Released Down, Down-Forward, Forward, Down, Down-Forward, Forward\r\nButton Press: Light Kick or Released Light Kick\r\nThis sequence defines a special move input like Ryu's Shoryuken, where the player must perform specific directional inputs followed by a button press.\r\n\r\nConclusion\r\nIn summary, this DSL facilitates the definition and execution of complex special move inputs in fighting games. It leverages tokenization, compilation, and evaluation to translate player input sequences into actionable commands within the game engine. By understanding and utilizing this DSL, game developers can create engaging and responsive gameplay experiences, ensuring that executing special moves feels intuitive and rewarding for players.\r\n",
 "pubDate": "May 13th, 2023",
 "title": "Making a DSL for a Fighting Game Command Parser",
 "subTitle": "making a dsl to define special move motions for fighting games",
 "forBricks": "$RichBoneHQ, 857-258-2506"
}

